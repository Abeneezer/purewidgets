/**
 * package doc widget
 */
package org.purewidgets.shared.im;

import java.util.ArrayList;
import java.util.List;

import org.purewidgets.shared.events.ActionEvent;
import org.purewidgets.shared.events.ActionListener;
import org.purewidgets.shared.events.WidgetInputEvent;
import org.purewidgets.shared.events.WidgetInputListener;
import org.purewidgets.shared.events.ReferenceCodeListener;
import org.purewidgets.shared.logging.Log;


/**
 * Represents a widget in the interaction manager.
 * A widget has a control type which defines the type of interactive feature it provides.
 *<p>
 * A widget has a id that identifies the widget in the application (so it
 * must be a unique id within the application) and one or more <code>WidgetOptions</code>
 * that correspond to items of the widget that can be separately selected by the
 * user.<p> 
 * Each <code>WidgetOption</code> will be assigned a reference code by the interaction
 * manager service. Reference codes are the human-readable references used by users to
 * select an option or a widget for input. When the set of reference codes
 * assigned to a widget changes (because the application created a new widget with the 
 * same widgetid, for example) the InteractionManager will notify the widget by calling
 * onReferenceCodesUpdated().
 * <p>
 * Widgets can have (and usually will) ActionListeners attached. An application
 * registers ActionListeners so that it will be notified of any event generated by the 
 * widget (usually in response to user input). 
 * <p>
 * Widgets may also have an InputListener. This works in a kind of Chain of Responsability 
 * pattern: If the Widget has an InputListener it will forward any input to this listener
 * and will not try to handle it or generate ActionEvents. This allows the client code
 * to register a PdWidget as an InputListener for the base widget so that it (the PdWidget)
 * will be responsible for handling input and generating the ActionEvents.
 * The same happens with the ReferenceCodeListener.
 * <p>
 * 
 * Subclasses of Widget can override the handleInput() to check for the validity of
 * the input and trigger an ActionEvent (ideally through the triggerActionEvent() method).
 *
 * 
 * 
 * @author Jorge C. S. Cardoso
 * 
 */
public class Widget implements Comparable<Widget> {
	/**
	 * The imperative/select control type.
	 */
	public static String CONTROL_TYPE_IMPERATIVE_SELECTION = "imperative_selection";
	
	/**
	 * The entry control type.
	 */
	public static String CONTROL_TYPE_ENTRY = "entry";
	
	/**
	 * The upload control type.
	 */
	public static String CONTROL_TYPE_UPLOAD = "upload";
	
	/**
	 * The download control type.
	 */
	public static String CONTROL_TYPE_DOWNLOAD = "download";
	
	/**
	 * The presence control type.
	 */
	public static String CONTROL_TYPE_PRESENCE = "presence";
	//TODO: composite

	/**
	 * The widget parameter name for the sorting order (used by the place interaction webpage to graphically sort the 
	 * widgets).
	 */
	public static String SORT_ORDER_PARAMETER_NAME = "purewidgets-sortorder";
	
	/**
	 * The placeId where the application that has this widget is running.
	 * Applications don't usually have to deal directly with this.
	 */
	private String placeId;

	/**
	 * The applicationId of the application that has this widget. Applications
	 * don't usually have to deal directly with this.
	 */
	private String applicationId;

	/**
	 * The id of this widget.
	 */
	protected String widgetId;
	
	
	/**
	 * The type of control that this widget implements
	 */
	private String controlType;
	

	/**
	 * A short description (label) for the widget. The descriptions
	 * can be used to generate a more informative GUI by other system applications.
	 *
	 */
	private String shortDescription;
	
	/**
	 * A long description for the widget. The descriptions
	 * can be used to generate a more informative GUI by other system applications.
	 */

	private String longDescription;
	
	
	/**
	 * The list of options of this widget
	 */
	protected ArrayList<WidgetOption> widgetOptions = new ArrayList<WidgetOption>();

	/**
	 * The list of parameters for this widget.
	 */
	private ArrayList<WidgetParameter> widgetParameters;
	
	/**
	 * The ActionListeners registered to receive high-level events from this
	 * widget.
	 */
	protected List<ActionListener> actionListeners = new ArrayList<ActionListener>();

	/**
	 * The InputListener for this widget. 
	 */
	protected WidgetInputListener inputListener;

	/**
	 * The ReferenceCodeListener for this widget. Widgets are themselves
	 * ReferenceCodeListeners but also propagate reference codes to other
	 * listeners (e.g. GuiWidgets)
	 */
	protected ReferenceCodeListener referenceCodeListener;

	
//	/**
//	 * Widgets dependent on this one.
//	 * Widget can be composed by other widgets.
//	 */
//	protected ArrayList<Widget> dependentWidgets;


	/**
	 * Creates a new Widget with the specified widget id, short description, long description, and widget options. 
	 * If the options parameter is null, one WidgetOption will be created with the same id as the widget's id.
	 * 
	 * By default, widgets are of type 'imperative/selection'.
	 * 
	 * @param widgetId The id for the widget.
	 * @param shortDescription The short description of the widget.
	 * @param longDescription The long description of the widget.
	 * @param options The list of WidgetOptions.
	 */
	public Widget(String widgetId, String shortDescription, String longDescription, ArrayList<WidgetOption> options) {
		this(widgetId, CONTROL_TYPE_IMPERATIVE_SELECTION, shortDescription, longDescription, options, null);
	}
	
	/**
	 * Creates a new Widget with the specified widget id, control type, short description, long description, and widget options. 
	 * If the options parameter is null, one WidgetOption will be created with the same id as the widget's id.
	 * 
	 * 
	 * @param widgetId The id for the widget.
	 * @param controlType The type of widget.
	 * @param shortDescription The short description of the widget.
	 * @param longDescription The long description of the widget.
	 * @param options The list of WidgetOptions.
	 */
	public Widget(String widgetId, String controlType, String shortDescription, String longDescription, ArrayList<WidgetOption> options, ArrayList<WidgetParameter> parameters) {
		this();
		
		this.controlType = controlType;
		this.shortDescription = shortDescription;
		this.longDescription = longDescription;
		
		this.setWidgetId(widgetId);

		if (options == null) {
			WidgetOption wo = new WidgetOption(widgetId);
			this.addWidgetOption(wo);
		} else {
			this.setWidgetOptions(options);
		}
		

		if ( null != parameters ) {
			this.widgetParameters = parameters;
		}

	}

	
	/**
	 * Creates a new Widget without data.
	 */
	protected Widget() {
		this.actionListeners = new ArrayList<ActionListener>();
		this.widgetOptions = new ArrayList<WidgetOption>();
//		this.dependentWidgets = new ArrayList<Widget>();
		this.widgetParameters = new ArrayList<WidgetParameter>();
	}

	
	/**
	 * Adds an action listener to the widget.
	 * 
	 * @param handler The action listener to add.
	 */
	public void addActionListener(ActionListener handler) {
		actionListeners.add(handler);
	}
	
//	/**
//	 * Adds a dependent widget.
//	 * 
//	 * @param widget
//	 */
//	public void addDependentWidget( Widget widget ) {
//		this.dependentWidgets.add(widget);
//	}
	
	/**
	 * Adds an option to this widget. 
	 * @param option the WidgetOption to add.
	 */
	public void addWidgetOption(WidgetOption option) {
		
		if (!this.widgetOptions.contains(option)) {
			this.widgetOptions.add(option);
		}
		
	}

	/**
	 * Compares this widget with another.
	 * @see Comparable#compareTo(Object)
	 */
	@Override
	public int compareTo(Widget other) {
		String thisSort = null;
		if ( this.widgetParameters.size() > 0) {
			for (WidgetParameter wp: this.widgetParameters) {
				if ( wp.getName().equals(SORT_ORDER_PARAMETER_NAME) ) {
					thisSort = wp.getValue();
				}
			}
		}
		
		String otherSort = null;
		if ( other.widgetParameters.size() > 0) {
			for (WidgetParameter wp: other.widgetParameters) {
				if ( wp.getName().equals(SORT_ORDER_PARAMETER_NAME) ) {
					otherSort = wp.getValue();
				}
			}
		}
		
		if ( thisSort == null && otherSort == null ) {
			return this.widgetId.compareTo(other.getWidgetId());
		} else if ( thisSort != null && otherSort != null ) {
			return thisSort.compareTo(otherSort);
		} else if ( thisSort != null ) {
			return -1;
		} else {
			return 1;
		}
	}
	

	/**
	 * Gets a widget parameter by name.
	 * @param parameterName The name of the parameter to retrieve.
	 * @return The WidgetParameter with the specified name; null, if no widget parameter with that name exists.
	 */
	public WidgetParameter getWidgetParameter(String parameterName) {
		for ( WidgetParameter param : this.widgetParameters ) {
			if ( param.getName().equals(parameterName) ) {
				return param;
			}
		}
		return null;
	}
	

	/**
	 * A helper method that sends an ActionEvent to all ActionListeners registered in this widget.
	 * 
	 * @param ae The ActionEvent to send
	 */
	public final void fireActionEvent(ActionEvent<?> ae) {
		for (ActionListener handler : actionListeners) {
			handler.onAction(ae);
		}
	}

	/**
	 * Gets the id of the application to which this widget belongs.
	 * 
	 * @return the id of the application to which this widget belongs.
	 */
	public String getApplicationId() {
		return applicationId;
	}
//
//	public ArrayList<Widget> getDependentWidget() {
//		return this.dependentWidgets;
//	}

	/**
	 * Gets the type of control of this widget.
	 * @return the type of control of this widget.
	 */
	public String getControlType() {
		return controlType;
	}


	/**
	 * Gets the long description for this widget.
	 * 
	 * @return the long description for this widget.
	 */
	public String getLongDescription() {
		return longDescription;
	}

	/**
	 * Gets the id of the place of the application to which this widget belongs.
	 * 
	 * @return the id of the place of the application to which this widget belongs.
	 */
	public String getPlaceId() {
		return placeId;
	}

	/**
	 * Gets the short description for this widget.
	 * @return the short description for this widget.
	 */
	public String getShortDescription() {
		return shortDescription;
	}

//	public void removeDependentWidget( Widget widget ) {
//		this.dependentWidgets.remove( widget );
//	}

	
	/**
	 * Gets the id of this widget.
	 * 
	 * @return The id of the widget.
	 * 
	 */
	public String getWidgetId() {
		return this.widgetId;
	}

	/**
	 * Returns the list of options of this widget.
	 * 
	 * @return The ArrayList of WidgetOption.
	 */
	public ArrayList<WidgetOption> getWidgetOptions() {
		return this.widgetOptions;
	}



	/**
	 * Gets the parameters for this widget.
	 * 
	 * @return the parameters for this widget.
	 */
	public ArrayList<WidgetParameter> getWidgetParameters() {
		return widgetParameters;
	}

	/**
	 * Handles input directed at this widget.
	 * If there is an WidgetInputListener attached to this widget, this widget will first call onInput on the listener
	 * before handling the input.
	 * 
	 * @param ie The list of input to handle.
	 */
	public final void onInput(ArrayList<WidgetInputEvent> ie) {
		Log.debugFinest(this, "Received event: " + ie);
		
		// You want null? You can't handle null...
		if (ie == null) {
			return;
		}

		/*
		 * On the client, input is handled by the PdWidget so we cascade the input to the InputListener (which is set to the GuiWidget).
		 * 
		 * On the server we just ask the subclass to handle the input by calling handleInput(). The handleInput() implementation in this
		 * class just triggers an ActionEvent. Subclasses may want to override this to validate input and create specific ActionEvents.
		 */
		if (null != this.inputListener) {
			/*
			 * On the client, cascade to the GuiWidget
			 */
			this.inputListener.onInput(ie);
			
		} 
		//else {
			/*
			 * On the server, handle the input
			 */
			this.handleInput(ie);
		//}
	}


	/**
	 * Handles changes in the reference codes.
	 * This method will call onReferenceCodesUpdated on the ReferenceCodeListener attached to this widget if it exists.
	 * If not, this widget will handle the update itself.
	 * 
	 */
	public final void onReferenceCodesUpdated() {
		Log.debugFinest(this, "Received onReferenceCodesUpdated");
		
		/*
		 * Cascade the input to the input listener for possible feedback
		 */
		if (null != this.referenceCodeListener) {
			Log.debugFinest(this, "Cascading onReferenceCodesUpdated to "
					+ this.referenceCodeListener);
			this.referenceCodeListener.onReferenceCodesUpdated();
		}  else {
			this.handleReferenceCodesUpdate();
		}

	}
	

	/**
	 * REmoves a previously added ActionListener.
	 * 
	 * @param handler The ActionListener to remove.
	 */
	public void removeActionListener(ActionListener handler) {
		actionListeners.remove(handler);

	}

	
	/**
	 * Sets the id of the application this widget belongs to.
	 * 
	 * @param applicationId the id of the application this widget belongs to.
	 */
	public void setApplicationId(String applicationId) {
		this.applicationId = applicationId;
	}


	/**
	 * Sets the input listener for this widget.
	 * 
	 * @param inputListener The input listener for this widget.
	 */
	public void setInputListener(WidgetInputListener inputListener) {
		this.inputListener = inputListener;

	}


	/**
	 * Sets the long description for this widget.
	 * 
	 * @param longDescription the long description to set
	 */
	public void setLongDescription(String longDescription) {
		this.longDescription = longDescription;
	}


	/**
	 * Sets the id of the place for this widget.
	 * 
	 * @param placeId The id of the place to set.
	 */
	public void setPlaceId(String placeId) {
		this.placeId = placeId;
	}


	/**
	 * Sets the reference code listener for this widget.
	 * 
	 * @param referenceCodeListener The  reference code listener to set.
	 */
	public void setReferenceCodeListener(
			ReferenceCodeListener referenceCodeListener) {
		this.referenceCodeListener = referenceCodeListener;
		

	}


	/**
	 * Sets the short description for this widget.
	 * 
	 * @param shortDescription the shortDescription to set
	 */
	public void setShortDescription(String shortDescription) {
		this.shortDescription = shortDescription;
	}


	/**
	 * Handles the received input. Concrete widgets should override this to
	 * validate input.
	 * 
	 * @param ie
	 */
	protected void handleInput(ArrayList <WidgetInputEvent> ie) {

		ActionEvent<Widget> ae;
		
		for (WidgetInputEvent inputEvent : ie) {
			ae = new ActionEvent<Widget>(inputEvent, this, null);
			
			this.fireActionEvent(ae);
		}
		

		
	}


	


	/**
	 * Concrete widgets may override this if they need to handle updated on the
	 * reference codes.
	 */
	protected void handleReferenceCodesUpdate() {
		//Log.debug(this, "handleReferenceCodesUpdate");
	}




	/**
	 * Sets this widget's options to the specified ArrayList. The existing
	 * options are discarded. This change is propagated immediately to the
	 * WidgetManager.
	 * 
	 * @see org.instantplaces.purewidgets.shared.widgets.WidgetInterface#setWidgetOptions(java.util.ArrayList)
	 */
	protected void setWidgetOptions(ArrayList<WidgetOption> options) {
		this.widgetOptions = options;
	}

	/**
	 * @param widgetID
	 */
	private void setWidgetId(String id) {
		/**
		 * A widget has always an unique ID within the application. If the user
		 * didn't pass one, one is generated automatically.
		 */
		if (id == null) {
			this.widgetId = String.valueOf(this.hashCode());
			Log.warn(this, "Null id, assigning object hashCode: " + this.widgetId);
		} else {
			this.widgetId =  id;//com.google.gwt.http.client.URL.decode(id);
		}
	}



}
